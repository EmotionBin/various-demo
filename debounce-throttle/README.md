# 防抖和节流

这里首先演示了一个简单的例子，一个 container，只要鼠标在上面移动的时候，计数器 count 的值就会加 1，在没有任何措施的情况下，只要鼠标在这个 container 上面移动的时候事件就会一直频繁的触发  

## 防抖

在一些业务场景中，有一个搜索输入框，根据输入的值调用 ajax 请求搜索结果，如果不使用一些措施，每次只要输入了信息，都会触发 ajax 请求，这会很浪费性能和服务器带宽，这不是一个合格的前端攻城狮的行为  

所以在这种场景下，会使用**防抖**来进行性能优化  

### 防抖原理

防抖原理简单概括为：**在事件触发结束后，n 秒后执行响应函数，如果在这个时间(n 秒)内，事件再次被触发，则重新计时**  

实现原理：**设置一个 timer 计时器(可以是全局变量也可以利用闭包)，每次触发事件的时候，先利用 clearTimeout 清空上一次的结果，再调用 setTimeout 函数，它的返回值赋值给 timer，如果在指定时间内重复触发事件， timer 都会重新赋值，所以不会触发事件回调函数；如果在指定时间内事件没有被再次触发，则到达指定时间后，则执行该事件的回调函数**

### 应用场景

1. 搜索框输入查询
2. scroll触发滚动事件
3. 表单验证
4. 按钮提交事件
5. 浏览器窗口缩放，resize事件

## 节流

节流和防抖有点相似，他们都是用来做性能优化的，例子都引用同一个例子，这里不再赘述  

### 节流原理

节流原理简单概括为：**持续触发事件，每隔一段时间，只执行一次事件**  

实现原理就不说了，看代码就好了，这里的节流我会给出几个版本  

1. 时间戳版本(第一次会触发，最后一次不会触发)
2. 定时器版本(第一次不会触发，最后一次会触发)
3. 时间戳和定时器结合版本(第一次会触发，最后一次也会触发)
4. 可配置版本(可自行配置，除了第一次不会触发，最后一次也不会触发的情况，具体配置情况见 demo)
 
### 应用场景

1. DOM 元素的拖拽功能实现(拖拽过程中每隔几秒做一些事情)
2. 射击游戏(每隔一段时间进行一次射击)
3. 计算鼠标移动距离(每隔一段时间计算一次鼠标移动的距离)
4. 监听 scroll 滚动事件(图片懒加载)



